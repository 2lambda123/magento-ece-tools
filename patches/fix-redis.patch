diff --git a/vendor/magento/module-backend/Model/Session/AdminConfig.php b/app/code/Magento/Backend/Model/Session/AdminConfig.php
index c23af37..3b5712f 100644
--- a/vendor/magento/module-backend/Model/Session/AdminConfig.php
+++ b/vendor/magento/module-backend/Model/Session/AdminConfig.php
@@ -14,8 +14,6 @@ use Magento\Framework\Session\Config;
 
 /**
  * Magento Backend session configuration
- *
- * @method Config setSaveHandler()
  */
 class AdminConfig extends Config
 {
diff --git a/app/etc/di.xml b/app/etc/di.xml
index e4c2693..69403de 100644
--- a/app/etc/di.xml
+++ b/app/etc/di.xml
@@ -141,6 +141,8 @@
     <preference for="Magento\Framework\Stdlib\DateTime\DateTimeFormatterInterface" type="Magento\Framework\Stdlib\DateTime\DateTimeFormatter"/>
     <preference for="Magento\Framework\Api\Search\SearchInterface" type="Magento\Framework\Search\Search"/>
     <preference for="Magento\Framework\View\Design\FileResolution\Fallback\ResolverInterface" type="Magento\Framework\View\Design\FileResolution\Fallback\Resolver\Simple" />
+    <preference for="Cm\RedisSession\Handler\ConfigInterface" type="Magento\Framework\Session\SaveHandler\Redis\Config"/>
+    <preference for="Cm\RedisSession\Handler\LoggerInterface" type="Magento\Framework\Session\SaveHandler\Redis\Logger"/>
     <type name="Magento\Framework\Model\ResourceModel\Db\TransactionManager" shared="false" />
     <type name="Magento\Framework\Logger\Handler\Base">
         <arguments>
@@ -186,9 +188,16 @@
         <arguments>
             <argument name="handlers" xsi:type="array">
                 <item name="db" xsi:type="string">Magento\Framework\Session\SaveHandler\DbTable</item>
+                <item name="redis" xsi:type="string">Magento\Framework\Session\SaveHandler\Redis</item>
             </argument>
         </arguments>
     </type>
+    <type name="Magento\Framework\Session\SaveHandler\Redis">
+        <arguments>
+            <argument name="config" xsi:type="object">Cm\RedisSession\Handler\ConfigInterface</argument>
+            <argument name="logger" xsi:type="object">Cm\RedisSession\Handler\LoggerInterface</argument>
+        </arguments>
+    </type>
     <virtualType name="interceptionConfigScope" type="Magento\Framework\Config\Scope">
         <arguments>
             <argument name="defaultScope" xsi:type="string">global</argument>
diff --git a/dev/tests/integration/testsuite/Magento/Framework/Session/ConfigTest.php b/dev/tests/integration/testsuite/Magento/Framework/Session/ConfigTest.php
index 869d9d3..187ac69 100644
--- a/dev/tests/integration/testsuite/Magento/Framework/Session/ConfigTest.php
+++ b/dev/tests/integration/testsuite/Magento/Framework/Session/ConfigTest.php
@@ -36,15 +36,12 @@ class ConfigTest extends \PHPUnit_Framework_TestCase
             $sessionManager->writeClose();
         }
         $this->deploymentConfigMock = $this->getMock('Magento\Framework\App\DeploymentConfig', [], [], '', false);
+
         $this->deploymentConfigMock->expects($this->at(0))
             ->method('get')
-            ->with($this->equalTo(Config::PARAM_SESSION_SAVE_METHOD), $this->anything())
-            ->will($this->returnValue('files'));
-        $this->deploymentConfigMock->expects($this->at(1))
-            ->method('get')
             ->with(Config::PARAM_SESSION_SAVE_PATH)
             ->will($this->returnValue(null));
-        $this->deploymentConfigMock->expects($this->at(2))
+        $this->deploymentConfigMock->expects($this->at(1))
             ->method('get')
             ->with(Config::PARAM_SESSION_CACHE_LIMITER)
             ->will($this->returnValue($this->_cacheLimiter));
@@ -86,11 +83,6 @@ class ConfigTest extends \PHPUnit_Framework_TestCase
         $this->assertEquals($this->_model->getSavePath(), $this->_model->getOption('save_path'));
     }
 
-    public function testGetSessionSaveMethod()
-    {
-        $this->assertEquals('files', $this->_model->getSaveHandler());
-    }
-
     /**
      * Unable to add integration tests for testGetLifetimePathNonDefault
      *
@@ -122,7 +114,6 @@ class ConfigTest extends \PHPUnit_Framework_TestCase
         return [
             ['save_path', 'getSavePath', __DIR__],
             ['name', 'getName', 'FOOBAR'],
-            ['save_handler', 'getSaveHandler', 'user'],
             ['gc_probability', 'getGcProbability', 42],
             ['gc_divisor', 'getGcDivisor', 3],
             ['gc_maxlifetime', 'getGcMaxlifetime', 180],
@@ -152,12 +143,6 @@ class ConfigTest extends \PHPUnit_Framework_TestCase
         $this->assertEquals('FOOBAR', $this->_model->getName());
     }
 
-    public function testSaveHandlerIsMutable()
-    {
-        $this->_model->setSaveHandler('user');
-        $this->assertEquals('user', $this->_model->getSaveHandler());
-    }
-
     public function testCookieLifetimeIsMutable()
     {
         $this->_model->setCookieLifetime(20);
@@ -295,7 +280,7 @@ class ConfigTest extends \PHPUnit_Framework_TestCase
             $this->markTestSkipped('Cannot set session.save_path with ini_set');
         }
 
-        $this->deploymentConfigMock->expects($this->at(1))
+        $this->deploymentConfigMock->expects($this->at(0))
             ->method('get')
             ->with(Config::PARAM_SESSION_SAVE_PATH)
             ->will($this->returnValue($given));
diff --git a/dev/tests/integration/testsuite/Magento/Framework/Session/SaveHandlerTest.php b/dev/tests/integration/testsuite/Magento/Framework/Session/SaveHandlerTest.php
new file mode 100644
index 0000000..ea36ac0
--- /dev/null
+++ b/dev/tests/integration/testsuite/Magento/Framework/Session/SaveHandlerTest.php
@@ -0,0 +1,89 @@
+<?php
+/**
+ * Copyright Â© 2016 Magento. All rights reserved.
+ * See COPYING.txt for license details.
+ */
+namespace Magento\Framework\Session;
+
+use Magento\Framework\App\DeploymentConfig;
+use Magento\Framework\Session\Config\ConfigInterface;
+use Magento\Framework\Session\SaveHandler;
+use Magento\Framework\App\ObjectManager;
+
+class SaveHandlerTest extends \PHPUnit_Framework_TestCase
+{
+    /** @var  \Magento\Framework\Session\Config\ConfigInterface */
+    private $sessionConfig;
+
+    /** @var  \Magento\Framework\App\DeploymentConfig */
+    private $deploymentConfig;
+
+    public function setUp()
+    {
+        $this->sessionConfig = ObjectManager::getInstance()->get(ConfigInterface::class);
+        $this->deploymentConfig = ObjectManager::getInstance()->get(DeploymentConfig::class);
+    }
+
+    /**
+     * Tests that the session handler is correctly set when object is created.
+     *
+     * @dataProvider saveHandlerProvider
+     * @param string $deploymentConfigHandler
+     * @param string $iniHandler
+     */
+    public function testSetSaveHandler($deploymentConfigHandler, $iniHandler)
+    {
+        // Set expected session.save_handler config
+        if ($deploymentConfigHandler) {
+            if ($deploymentConfigHandler !== 'files') {
+                $expected = 'user';
+            } else {
+                $expected = $deploymentConfigHandler;
+            }
+        } else if ($iniHandler) {
+            $expected = $iniHandler;
+        } else {
+            $expected = SaveHandlerInterface::DEFAULT_HANDLER;
+        }
+
+        // Set ini configuration
+        if ($iniHandler) {
+            $oldIni = ini_set('session.save_handler', $iniHandler);
+        }
+
+        /** @var DeploymentConfig | \PHPUnit_Framework_MockObject_MockObject $deploymentConfigMock */
+        $deploymentConfigMock = $this->getMockBuilder(DeploymentConfig::class)
+            ->disableOriginalConstructor()
+            ->getMock();
+        $deploymentConfigMock->expects($this->once())
+            ->method('get')
+            ->with(Config::PARAM_SESSION_SAVE_METHOD, SaveHandlerInterface::DEFAULT_HANDLER)
+            ->willReturn($deploymentConfigHandler ?: SaveHandlerInterface::DEFAULT_HANDLER);
+
+        new SaveHandler(
+            ObjectManager::getInstance()->get(SaveHandlerFactory::class),
+            $deploymentConfigMock
+        );
+
+        // Test expectation
+        $this->assertEquals(
+            $expected,
+            ObjectManager::getInstance()->get(ConfigInterface::class)->getOption('session.save_handler')
+        );
+
+        // Reset ini configuration
+        if (isset($oldIni)) {
+            ini_set('session.save_handler', $oldIni);
+        }
+    }
+
+    public function saveHandlerProvider()
+    {
+        return [
+            ['db', false],
+            ['db', 'files'],
+            [false, 'files'],
+            [false, false],
+        ];
+    }
+}
diff --git a/lib/internal/Credis/Client.php b/lib/internal/Credis/Client.php
deleted file mode 100644
index 5945709..0000000
--- a/lib/internal/Credis/Client.php
+++ /dev/null
@@ -1,1113 +0,0 @@
-<?php
-/**
- * Credis_Client (a fork of Redisent)
- *
- * Most commands are compatible with phpredis library:
- *   - use "pipeline()" to start a pipeline of commands instead of multi(Redis::PIPELINE)
- *   - any arrays passed as arguments will be flattened automatically
- *   - setOption and getOption are not supported in standalone mode
- *   - order of arguments follows redis-cli instead of phpredis where they differ (lrem)
- *
- * - Uses phpredis library if extension is installed for better performance.
- * - Establishes connection lazily.
- * - Supports tcp and unix sockets.
- * - Reconnects automatically unless a watch or transaction is in progress.
- * - Can set automatic retry connection attempts for iffy Redis connections.
- *
- * @author Colin Mollenhour <colin@mollenhour.com>
- * @copyright 2011 Colin Mollenhour <colin@mollenhour.com>
- * @license http://www.opensource.org/licenses/mit-license.php The MIT License
- * @package Credis_Client
- */
-
-if( ! defined('CRLF')) define('CRLF', sprintf('%s%s', chr(13), chr(10)));
-
-/**
- * Credis-specific errors, wraps native Redis errors
- */
-class CredisException extends Exception
-{
-
-    const CODE_TIMED_OUT = 1;
-    const CODE_DISCONNECTED = 2;
-
-    public function __construct($message, $code = 0, $exception = NULL)
-    {
-        if ($exception && get_class($exception) == 'RedisException' && $message == 'read error on connection') {
-            $code = CredisException::CODE_DISCONNECTED;
-        }
-        parent::__construct($message, $code, $exception);
-    }
-
-}
-
-/**
- * Credis_Client, a lightweight Redis PHP standalone client and phpredis wrapper
- *
- * Server/Connection:
- * @method Credis_Client pipeline()
- * @method Credis_Client multi()
- * @method array         exec()
- * @method string        flushAll()
- * @method string        flushDb()
- * @method array         info()
- * @method bool|array    config(string $setGet, string $key, string $value = null)
- *
- * Keys:
- * @method int           del(string $key)
- * @method int           exists(string $key)
- * @method int           expire(string $key, int $seconds)
- * @method int           expireAt(string $key, int $timestamp)
- * @method array         keys(string $key)
- * @method int           persist(string $key)
- * @method bool          rename(string $key, string $newKey)
- * @method bool          renameNx(string $key, string $newKey)
- * @method array         sort(string $key, string $arg1, string $valueN = null)
- * @method int           ttl(string $key)
- * @method string        type(string $key)
- *
- * Scalars:
- * @method int           append(string $key, string $value)
- * @method int           decr(string $key)
- * @method int           decrBy(string $key, int $decrement)
- * @method bool|string   get(string $key)
- * @method int           getBit(string $key, int $offset)
- * @method string        getRange(string $key, int $start, int $end)
- * @method string        getSet(string $key, string $value)
- * @method int           incr(string $key)
- * @method int           incrBy(string $key, int $decrement)
- * @method array         mGet(array $keys)
- * @method bool          mSet(array $keysValues)
- * @method int           mSetNx(array $keysValues)
- * @method bool          set(string $key, string $value)
- * @method int           setBit(string $key, int $offset, int $value)
- * @method bool          setEx(string $key, int $seconds, string $value)
- * @method int           setNx(string $key, string $value)
- * @method int           setRange(string $key, int $offset, int $value)
- * @method int           strLen(string $key)
- *
- * Sets:
- * @method int           sAdd(string $key, mixed $value, string $valueN = null)
- * @method int           sRem(string $key, mixed $value, string $valueN = null)
- * @method array         sMembers(string $key)
- * @method array         sUnion(mixed $keyOrArray, string $valueN = null)
- * @method array         sInter(mixed $keyOrArray, string $valueN = null)
- * @method array         sDiff(mixed $keyOrArray, string $valueN = null)
- * @method string        sPop(string $key)
- * @method int           sCard(string $key)
- * @method int           sIsMember(string $key, string $member)
- * @method int           sMove(string $source, string $dest, string $member)
- * @method string|array  sRandMember(string $key, int $count = null)
- * @method int           sUnionStore(string $dest, string $key1, string $key2 = null)
- * @method int           sInterStore(string $dest, string $key1, string $key2 = null)
- * @method int           sDiffStore(string $dest, string $key1, string $key2 = null)
- *
- * Hashes:
- * @method bool|int      hSet(string $key, string $field, string $value)
- * @method bool          hSetNx(string $key, string $field, string $value)
- * @method bool|string   hGet(string $key, string $field)
- * @method bool|int      hLen(string $key)
- * @method bool          hDel(string $key, string $field)
- * @method array         hKeys(string $key, string $field)
- * @method array         hVals(string $key, string $field)
- * @method array         hGetAll(string $key)
- * @method bool          hExists(string $key, string $field)
- * @method int           hIncrBy(string $key, string $field, int $value)
- * @method bool          hMSet(string $key, array $keysValues)
- * @method array         hMGet(string $key, array $fields)
- *
- * Lists:
- * @method array|null    blPop(string $keyN, int $timeout)
- * @method array|null    brPop(string $keyN, int $timeout)
- * @method array|null    brPoplPush(string $source, string $destination, int $timeout)
- * @method string|null   lIndex(string $key, int $index)
- * @method int           lInsert(string $key, string $beforeAfter, string $pivot, string $value)
- * @method int           lLen(string $key)
- * @method string|null   lPop(string $key)
- * @method int           lPush(string $key, mixed $value, mixed $valueN = null)
- * @method int           lPushX(string $key, mixed $value)
- * @method array         lRange(string $key, int $start, int $stop)
- * @method int           lRem(string $key, int $count, mixed $value)
- * @method bool          lSet(string $key, int $index, mixed $value)
- * @method bool          lTrim(string $key, int $start, int $stop)
- * @method string|null   rPop(string $key)
- * @method string|null   rPoplPush(string $source, string $destination)
- * @method int           rPush(string $key, mixed $value, mixed $valueN = null)
- * @method int           rPushX(string $key, mixed $value)
- *
- * Sorted Sets:
- * TODO
- *
- * Pub/Sub
- * @method array         pUnsubscribe(mixed $pattern, string $patternN = NULL))
- * @method array         unsubscribe(mixed $channel, string $channelN = NULL))
- * @method int           publish(string $channel, string $message)
- * @method int|array     pubsub(string $subCommand, $arg = NULL)
- *
- * Scripting:
- * @method string|int    script(string $command, string $arg1 = null)
- * @method string|int|array|bool eval(string $script, array $keys = NULL, array $args = NULL)
- * @method string|int|array|bool evalSha(string $script, array $keys = NULL, array $args = NULL)
- */
-class Credis_Client {
-
-    const TYPE_STRING      = 'string';
-    const TYPE_LIST        = 'list';
-    const TYPE_SET         = 'set';
-    const TYPE_ZSET        = 'zset';
-    const TYPE_HASH        = 'hash';
-    const TYPE_NONE        = 'none';
-    const FREAD_BLOCK_SIZE = 8192;
-
-    /**
-     * Socket connection to the Redis server or Redis library instance
-     * @var resource|Redis
-     */
-    protected $redis;
-    protected $redisMulti;
-
-    /**
-     * Host of the Redis server
-     * @var string
-     */
-    protected $host;
-    
-    /**
-     * Port on which the Redis server is running
-     * @var integer
-     */
-    protected $port;
-
-    /**
-     * Timeout for connecting to Redis server
-     * @var float
-     */
-    protected $timeout;
-
-    /**
-     * Timeout for reading response from Redis server
-     * @var float
-     */
-    protected $readTimeout;
-
-    /**
-     * Unique identifier for persistent connections
-     * @var string
-     */
-    protected $persistent;
-
-    /**
-     * @var bool
-     */
-    protected $closeOnDestruct = TRUE;
-
-    /**
-     * @var bool
-     */
-    protected $connected = FALSE;
-
-    /**
-     * @var bool
-     */
-    protected $standalone;
-
-    /**
-     * @var int
-     */
-    protected $maxConnectRetries = 0;
-
-    /**
-     * @var int
-     */
-    protected $connectFailures = 0;
-
-    /**
-     * @var bool
-     */
-    protected $usePipeline = FALSE;
-
-    /**
-     * @var array
-     */
-    protected $commandNames;
-
-    /**
-     * @var string
-     */
-    protected $commands;
-
-    /**
-     * @var bool
-     */
-    protected $isMulti = FALSE;
-
-    /**
-     * @var bool
-     */
-    protected $isWatching = FALSE;
-
-    /**
-     * @var string
-     */
-    protected $authPassword;
-
-    /**
-     * @var int
-     */
-    protected $selectedDb = 0;
-
-    /**
-     * Aliases for backwards compatibility with phpredis
-     * @var array
-     */
-    protected $wrapperMethods = array('delete' => 'del', 'getkeys' => 'keys', 'sremove' => 'srem');
-
-    /**
-     * @var array
-     */
-    protected $renamedCommands;
-
-    /**
-     * @var int
-     */
-    protected $requests = 0;
-
-    /**
-     * Creates a Redisent connection to the Redis server on host {@link $host} and port {@link $port}.
-     * $host may also be a path to a unix socket or a string in the form of tcp://[hostname]:[port] or unix://[path]
-     *
-     * @param string $host The hostname of the Redis server
-     * @param integer $port The port number of the Redis server
-     * @param float $timeout  Timeout period in seconds
-     * @param string $persistent  Flag to establish persistent connection
-     * @param int $db The selected datbase of the Redis server
-     * @param string $password The authentication password of the Redis server
-     */
-    public function __construct($host = '127.0.0.1', $port = 6379, $timeout = null, $persistent = '', $db = 0, $password = null)
-    {
-        $this->host = (string) $host;
-        $this->port = (int) $port;
-        $this->timeout = $timeout;
-        $this->persistent = (string) $persistent;
-        $this->standalone = ! extension_loaded('redis');
-        $this->authPassword = $password;
-        $this->selectedDb = (int)$db;
-        $this->convertHost();
-    }
-
-    public function __destruct()
-    {
-        if ($this->closeOnDestruct) {
-            $this->close();
-        }
-    }
-    /**
-     * Return the host of the Redis instance
-     * @return string
-     */
-    public function getHost()
-    {
-        return $this->host;
-    }
-    /**
-     * Return the port of the Redis instance
-     * @return int
-     */
-    public function getPort()
-    {
-        return $this->port;
-    }
-
-    /**
-     * Return the selected database
-     * @return int
-     */
-    public function getSelectedDb()
-    {
-        return $this->selectedDb;
-    }
-    /**
-     * @return string
-     */
-    public function getPersistence()
-    {
-        return $this->persistent;
-    }
-    /**
-     * @throws CredisException
-     * @return Credis_Client
-     */
-    public function forceStandalone()
-    {
-        if($this->connected) {
-            throw new CredisException('Cannot force Credis_Client to use standalone PHP driver after a connection has already been established.');
-        }
-        $this->standalone = TRUE;
-        return $this;
-    }
-
-    /**
-     * @param int $retries
-     * @return Credis_Client
-     */
-    public function setMaxConnectRetries($retries)
-    {
-        $this->maxConnectRetries = $retries;
-        return $this;
-    }
-
-    /**
-     * @param bool $flag
-     * @return Credis_Client
-     */
-    public function setCloseOnDestruct($flag)
-    {
-        $this->closeOnDestruct = $flag;
-        return $this;
-    }
-    protected function convertHost()
-    {
-        if (preg_match('#^(tcp|unix)://(.*)$#', $this->host, $matches)) {
-            if($matches[1] == 'tcp') {
-                if ( ! preg_match('#^([^:]+)(:([0-9]+))?(/(.+))?$#', $matches[2], $matches)) {
-                    throw new CredisException('Invalid host format; expected tcp://host[:port][/persistence_identifier]');
-                }
-                $this->host = $matches[1];
-                $this->port = (int) (isset($matches[3]) ? $matches[3] : 6379);
-                $this->persistent = isset($matches[5]) ? $matches[5] : '';
-            } else {
-                $this->host = $matches[2];
-                $this->port = NULL;
-                if (substr($this->host,0,1) != '/') {
-                    throw new CredisException('Invalid unix socket format; expected unix:///path/to/redis.sock');
-                }
-            }
-        }
-        if ($this->port !== NULL && substr($this->host,0,1) == '/') {
-            $this->port = NULL;
-        }
-    }
-    /**
-     * @throws CredisException
-     * @return Credis_Client
-     */
-    public function connect()
-    {
-        if ($this->connected) {
-            return $this;
-        }
-        if ($this->standalone) {
-            $flags = STREAM_CLIENT_CONNECT;
-            $remote_socket = $this->port === NULL
-                ? 'unix://'.$this->host
-                : 'tcp://'.$this->host.':'.$this->port;
-            if ($this->persistent) {
-                if ($this->port === NULL) { // Unix socket
-                    throw new CredisException('Persistent connections to UNIX sockets are not supported in standalone mode.');
-                }
-                $remote_socket .= '/'.$this->persistent;
-                $flags = $flags | STREAM_CLIENT_PERSISTENT;
-            }
-            $result = $this->redis = @stream_socket_client($remote_socket, $errno, $errstr, $this->timeout !== null ? $this->timeout : 2.5, $flags);
-        }
-        else {
-            if ( ! $this->redis) {
-                $this->redis = new Redis;
-            }
-            $result = $this->persistent
-                ? $this->redis->pconnect($this->host, $this->port, $this->timeout, $this->persistent)
-                : $this->redis->connect($this->host, $this->port, $this->timeout);
-        }
-
-        // Use recursion for connection retries
-        if ( ! $result) {
-            $this->connectFailures++;
-            if ($this->connectFailures <= $this->maxConnectRetries) {
-                return $this->connect();
-            }
-            $failures = $this->connectFailures;
-            $this->connectFailures = 0;
-            throw new CredisException("Connection to Redis failed after $failures failures." . (isset($errno) && isset($errstr) ? "Last Error : ({$errno}) {$errstr}" : ""));
-        }
-
-        $this->connectFailures = 0;
-        $this->connected = TRUE;
-
-        // Set read timeout
-        if ($this->readTimeout) {
-            $this->setReadTimeout($this->readTimeout);
-        }
-
-        if($this->authPassword !== null) {
-            $this->auth($this->authPassword);
-        }
-        if($this->selectedDb !== 0) {
-            $this->select($this->selectedDb);
-        }
-        return $this;
-    }
-    /**
-     * @return bool
-     */
-    public function isConnected()
-    {
-        return $this->connected;
-    }
-    /**
-     * Set the read timeout for the connection. Use 0 to disable timeouts entirely (or use a very long timeout
-     * if not supported).
-     *
-     * @param int $timeout 0 (or -1) for no timeout, otherwise number of seconds
-     * @throws CredisException
-     * @return Credis_Client
-     */
-    public function setReadTimeout($timeout)
-    {
-        if ($timeout < -1) {
-            throw new CredisException('Timeout values less than -1 are not accepted.');
-        }
-        $this->readTimeout = $timeout;
-        if ($this->connected) {
-            if ($this->standalone) {
-                $timeout = $timeout <= 0 ? 315360000 : $timeout; // Ten-year timeout
-                stream_set_blocking($this->redis, TRUE);
-                stream_set_timeout($this->redis, (int) floor($timeout), ($timeout - floor($timeout)) * 1000000);
-            } else if (defined('Redis::OPT_READ_TIMEOUT')) {
-                // supported in phpredis 2.2.3
-                // a timeout value of -1 means reads will not timeout
-                $timeout = $timeout == 0 ? -1 : $timeout;
-                $this->redis->setOption(Redis::OPT_READ_TIMEOUT, $timeout);
-            }
-        }
-        return $this;
-    }
-
-    /**
-     * @return bool
-     */
-    public function close()
-    {
-        $result = TRUE;
-        if ($this->connected && ! $this->persistent) {
-            try {
-                $result = $this->standalone ? fclose($this->redis) : $this->redis->close();
-                $this->connected = FALSE;
-            } catch (Exception $e) {
-                ; // Ignore exceptions on close
-            }
-        }
-        return $result;
-    }
-
-    /**
-     * Enabled command renaming and provide mapping method. Supported methods are:
-     *
-     * 1. renameCommand('foo') // Salted md5 hash for all commands -> md5('foo'.$command)
-     * 2. renameCommand(function($command){ return 'my'.$command; }); // Callable
-     * 3. renameCommand('get', 'foo') // Single command -> alias
-     * 4. renameCommand(['get' => 'foo', 'set' => 'bar']) // Full map of [command -> alias]
-     *
-     * @param string|callable|array $command
-     * @param string|null $alias
-     * @return $this
-     */
-    public function renameCommand($command, $alias = NULL)
-    {
-        if ( ! $this->standalone) {
-            $this->forceStandalone();
-        }
-        if ($alias === NULL) {
-            $this->renamedCommands = $command;
-        } else {
-            if ( ! $this->renamedCommands) {
-                $this->renamedCommands = array();
-            }
-            $this->renamedCommands[$command] = $alias;
-        }
-        return $this;
-    }
-
-    /**
-     * @param $command
-     */
-    public function getRenamedCommand($command)
-    {
-        static $map;
-
-        // Command renaming not enabled
-        if ($this->renamedCommands === NULL) {
-            return $command;
-        }
-
-        // Initialize command map
-        if ($map === NULL) {
-            if (is_array($this->renamedCommands)) {
-                $map = $this->renamedCommands;
-            } else {
-                $map = array();
-            }
-        }
-
-        // Generate and return cached result
-        if ( ! isset($map[$command])) {
-            // String means all commands are hashed with salted md5
-            if (is_string($this->renamedCommands)) {
-                $map[$command] = md5($this->renamedCommands.$command);
-            }
-            // Would already be set in $map if it was intended to be renamed
-            else if (is_array($this->renamedCommands)) {
-                return $command;
-            }
-            // User-supplied function
-            else if (is_callable($this->renamedCommands)) {
-                $map[$command] = call_user_func($this->renamedCommands, $command);
-            }
-        }
-        return $map[$command];
-    }
-
-    /**
-     * @param string $password
-     * @return bool
-     */
-    public function auth($password)
-    {
-        $response = $this->__call('auth', array($password));
-        $this->authPassword = $password;
-        return $response;
-    }
-
-    /**
-     * @param int $index
-     * @return bool
-     */
-    public function select($index)
-    {
-        $response = $this->__call('select', array($index));
-        $this->selectedDb = (int) $index;
-        return $response;
-    }
-
-    /**
-     * @param string|array $patterns
-     * @param $callback
-     * @return $this|array|bool|Credis_Client|mixed|null|string
-     * @throws CredisException
-     */
-    public function pSubscribe($patterns, $callback)
-    {
-        if ( ! $this->standalone) {
-            return $this->__call('pSubscribe', array((array)$patterns, $callback));
-        }
-
-        // Standalone mode: use infinite loop to subscribe until timeout
-        $patternCount = is_array($patterns) ? count($patterns) : 1;
-        while ($patternCount--) {
-            if (isset($status)) {
-                list($command, $pattern, $status) = $this->read_reply();
-            } else {
-                list($command, $pattern, $status) = $this->__call('psubscribe', array($patterns));
-            }
-            if ( ! $status) {
-                throw new CredisException('Invalid pSubscribe response.');
-            }
-        }
-        try {
-            while (1) {
-                list($type, $pattern, $channel, $message) = $this->read_reply();
-                if ($type != 'pmessage') {
-                    throw new CredisException('Received non-pmessage reply.');
-                }
-                $callback($this, $pattern, $channel, $message);
-            }
-        } catch (CredisException $e) {
-            if ($e->getCode() == CredisException::CODE_TIMED_OUT) {
-                try {
-                    list($command, $pattern, $status) = $this->pUnsubscribe($patterns);
-                    while ($status !== 0) {
-                        list($command, $pattern, $status) = $this->read_reply();
-                    }
-                } catch (CredisException $e2) {
-                    throw $e2;
-                }
-            }
-            throw $e;
-        }
-    }
-
-    /**
-     * @param string|array $channels
-     * @param $callback
-     * @throws CredisException
-     * @return $this|array|bool|Credis_Client|mixed|null|string
-     */
-    public function subscribe($channels, $callback)
-    {
-        if ( ! $this->standalone) {
-            return $this->__call('subscribe', array((array)$channels, $callback));
-        }
-
-        // Standalone mode: use infinite loop to subscribe until timeout
-        $channelCount = is_array($channels) ? count($channels) : 1;
-        while ($channelCount--) {
-            if (isset($status)) {
-                list($command, $channel, $status) = $this->read_reply();
-            } else {
-                list($command, $channel, $status) = $this->__call('subscribe', array($channels));
-            }
-            if ( ! $status) {
-                throw new CredisException('Invalid subscribe response.');
-            }
-        }
-        try {
-            while (1) {
-                list($type, $channel, $message) = $this->read_reply();
-                if ($type != 'message') {
-                    throw new CredisException('Received non-message reply.');
-                }
-                $callback($this, $channel, $message);
-            }
-        } catch (CredisException $e) {
-            if ($e->getCode() == CredisException::CODE_TIMED_OUT) {
-                try {
-                    list($command, $channel, $status) = $this->unsubscribe($channels);
-                    while ($status !== 0) {
-                        list($command, $channel, $status) = $this->read_reply();
-                    }
-                } catch (CredisException $e2) {
-                    throw $e2;
-                }
-            }
-            throw $e;
-        }
-    }
-
-    public function __call($name, $args)
-    {
-        // Lazy connection
-        $this->connect();
-
-        $name = strtolower($name);
-
-        // Send request via native PHP
-        if($this->standalone)
-        {
-            switch ($name) {
-                case 'eval':
-                case 'evalsha':
-                    $script = array_shift($args);
-                    $keys = (array) array_shift($args);
-                    $eArgs = (array) array_shift($args);
-                    $args = array($script, count($keys), $keys, $eArgs);
-                    break;
-            }
-            // Flatten arguments
-            $argsFlat = NULL;
-            foreach($args as $index => $arg) {
-                if(is_array($arg)) {
-                    if($argsFlat === NULL) {
-                        $argsFlat = array_slice($args, 0, $index);
-                    }
-                    if($name == 'mset' || $name == 'msetnx' || $name == 'hmset') {
-                      foreach($arg as $key => $value) {
-                        $argsFlat[] = $key;
-                        $argsFlat[] = $value;
-                      }
-                    } else {
-                      $argsFlat = array_merge($argsFlat, $arg);
-                    }
-                } else if($argsFlat !== NULL) {
-                    $argsFlat[] = $arg;
-                }
-            }
-            if($argsFlat !== NULL) {
-                $args = $argsFlat;
-                $argsFlat = NULL;
-            }
-
-            // In pipeline mode
-            if($this->usePipeline)
-            {
-                if($name == 'pipeline') {
-                    throw new CredisException('A pipeline is already in use and only one pipeline is supported.');
-                }
-                else if($name == 'exec') {
-                    if($this->isMulti) {
-                        $this->commandNames[] = $name;
-                        $this->commands .= self::_prepare_command(array($this->getRenamedCommand($name)));
-                    }
-
-                    // Write request
-                    if($this->commands) {
-                        $this->write_command($this->commands);
-                    }
-                    $this->commands = NULL;
-
-                    // Read response
-                    $response = array();
-                    foreach($this->commandNames as $command) {
-                        $response[] = $this->read_reply($command);
-                    }
-                    $this->commandNames = NULL;
-
-                    if($this->isMulti) {
-                        $response = array_pop($response);
-                    }
-                    $this->usePipeline = $this->isMulti = FALSE;
-                    return $response;
-                }
-                else {
-                    if($name == 'multi') {
-                        $this->isMulti = TRUE;
-                    }
-                    array_unshift($args, $this->getRenamedCommand($name));
-                    $this->commandNames[] = $name;
-                    $this->commands .= self::_prepare_command($args);
-                    return $this;
-                }
-            }
-
-            // Start pipeline mode
-            if($name == 'pipeline')
-            {
-                $this->usePipeline = TRUE;
-                $this->commandNames = array();
-                $this->commands = '';
-                return $this;
-            }
-
-            // If unwatching, allow reconnect with no error thrown
-            if($name == 'unwatch') {
-                $this->isWatching = FALSE;
-            }
-
-            // Non-pipeline mode
-            array_unshift($args, $this->getRenamedCommand($name));
-            $command = self::_prepare_command($args);
-            $this->write_command($command);
-            $response = $this->read_reply($name);
-
-            // Watch mode disables reconnect so error is thrown
-            if($name == 'watch') {
-                $this->isWatching = TRUE;
-            }
-            // Transaction mode
-            else if($this->isMulti && ($name == 'exec' || $name == 'discard')) {
-                $this->isMulti = FALSE;
-            }
-            // Started transaction
-            else if($this->isMulti || $name == 'multi') {
-                $this->isMulti = TRUE;
-                $response = $this;
-            }
-        }
-
-        // Send request via phpredis client
-        else
-        {
-            // Tweak arguments
-            switch($name) {
-                case 'get':   // optimize common cases
-                case 'set':
-                case 'hget':
-                case 'hset':
-                case 'setex':
-                case 'mset':
-                case 'msetnx':
-                case 'hmset':
-                case 'hmget':
-                case 'del':
-                    break;
-                case 'mget':
-                    if(isset($args[0]) && ! is_array($args[0])) {
-                        $args = array($args);
-                    }
-                    break;
-                case 'lrem':
-                    $args = array($args[0], $args[2], $args[1]);
-                    break;
-                case 'eval':
-                case 'evalsha':
-                    if (isset($args[1]) && is_array($args[1])) {
-                        $cKeys = $args[1];
-                    } elseif (isset($args[1]) && is_string($args[1])) {
-                        $cKeys = array($args[1]);
-                    } else {
-                        $cKeys = array();
-                    }
-                    if (isset($args[2]) && is_array($args[2])) {
-                        $cArgs = $args[2];
-                    } elseif (isset($args[2]) && is_string($args[2])) {
-                        $cArgs = array($args[2]);
-                    } else {
-                        $cArgs = array();
-                    }
-                    $args = array($args[0], array_merge($cKeys, $cArgs), count($cKeys));
-                    break;
-                case 'subscribe':
-                case 'psubscribe':
-                    break;
-                default:
-                    // Flatten arguments
-                    $argsFlat = NULL;
-                    foreach($args as $index => $arg) {
-                        if(is_array($arg)) {
-                            if($argsFlat === NULL) {
-                                $argsFlat = array_slice($args, 0, $index);
-                            }
-                            $argsFlat = array_merge($argsFlat, $arg);
-                        } else if($argsFlat !== NULL) {
-                            $argsFlat[] = $arg;
-                        }
-                    }
-                    if($argsFlat !== NULL) {
-                        $args = $argsFlat;
-                        $argsFlat = NULL;
-                    }
-            }
-
-            try {
-                // Proxy pipeline mode to the phpredis library
-                if($name == 'pipeline' || $name == 'multi') {
-                    if($this->isMulti) {
-                        return $this;
-                    } else {
-                        $this->isMulti = TRUE;
-                        $this->redisMulti = call_user_func_array(array($this->redis, $name), $args);
-                    }
-                }
-                else if($name == 'exec' || $name == 'discard') {
-                    $this->isMulti = FALSE;
-                    $response = $this->redisMulti->$name();
-                    $this->redisMulti = NULL;
-                    #echo "> $name : ".substr(print_r($response, TRUE),0,100)."\n";
-                    return $response;
-                }
-
-                // Use aliases to be compatible with phpredis wrapper
-                if(isset($this->wrapperMethods[$name])) {
-                    $name = $this->wrapperMethods[$name];
-                }
-
-                // Multi and pipeline return self for chaining
-                if($this->isMulti) {
-                    call_user_func_array(array($this->redisMulti, $name), $args);
-                    return $this;
-                }
-
-                // Send request, retry one time when using persistent connections on the first request only
-                $this->requests++;
-                try {
-                    $response = call_user_func_array(array($this->redis, $name), $args);
-                } catch (RedisException $e) {
-                    if ($this->persistent && $this->requests == 1 && $e->getMessage() == 'read error on connection') {
-                        $this->connected = FALSE;
-                        $this->connect();
-                        $response = call_user_func_array(array($this->redis, $name), $args);
-                    } else {
-                        throw $e;
-                    }
-                }
-            }
-            // Wrap exceptions
-            catch(RedisException $e) {
-                $code = 0;
-                if ( ! ($result = $this->redis->IsConnected())) {
-                    $this->connected = FALSE;
-                    $code = CredisException::CODE_DISCONNECTED;
-                }
-                throw new CredisException($e->getMessage(), $code, $e);
-            }
-
-            #echo "> $name : ".substr(print_r($response, TRUE),0,100)."\n";
-
-            // change return values where it is too difficult to minim in standalone mode
-            switch($name)
-            {
-                case 'hmget':
-                    $response = array_values($response);
-                    break;
-
-                case 'type':
-                    $typeMap = array(
-                      self::TYPE_NONE,
-                      self::TYPE_STRING,
-                      self::TYPE_SET,
-                      self::TYPE_LIST,
-                      self::TYPE_ZSET,
-                      self::TYPE_HASH,
-                    );
-                    $response = $typeMap[$response];
-                    break;
-
-                // Handle scripting errors
-                case 'eval':
-                case 'evalsha':
-                case 'script':
-                    $error = $this->redis->getLastError();
-                    $this->redis->clearLastError();
-                    if ($error && substr($error,0,8) == 'NOSCRIPT') {
-                        $response = NULL;
-                    } else if ($error) {
-                        throw new CredisException($error);
-                    }
-                    break;
-                default:
-                    $error = $this->redis->getLastError();
-                    $this->redis->clearLastError();
-                    if ($error) {
-                        throw new CredisException($error);
-                    }
-                    break;
-            }
-        }
-
-        return $response;
-    }
-
-    protected function write_command($command)
-    {
-        // Reconnect on lost connection (Redis server "timeout" exceeded since last command)
-        if(feof($this->redis)) {
-            $this->close();
-            // If a watch or transaction was in progress and connection was lost, throw error rather than reconnect
-            // since transaction/watch state will be lost.
-            if(($this->isMulti && ! $this->usePipeline) || $this->isWatching) {
-                $this->isMulti = $this->isWatching = FALSE;
-                throw new CredisException('Lost connection to Redis server during watch or transaction.');
-            }
-            $this->connected = FALSE;
-            $this->connect();
-            if($this->authPassword) {
-                $this->auth($this->authPassword);
-            }
-            if($this->selectedDb != 0) {
-                $this->select($this->selectedDb);
-            }
-        }
-
-        $commandLen = strlen($command);
-        for ($written = 0; $written < $commandLen; $written += $fwrite) {
-            $fwrite = fwrite($this->redis, substr($command, $written));
-            if ($fwrite === FALSE || $fwrite == 0 ) {
-                $this->connected = FALSE;
-                throw new CredisException('Failed to write entire command to stream');
-            }
-        }
-    }
-
-    protected function read_reply($name = '')
-    {
-        $reply = fgets($this->redis);
-        if($reply === FALSE) {
-            $info = stream_get_meta_data($this->redis);
-            if ($info['timed_out']) {
-                throw new CredisException('Read operation timed out.', CredisException::CODE_TIMED_OUT);
-            } else {
-                $this->connected = FALSE;
-                throw new CredisException('Lost connection to Redis server.', CredisException::CODE_DISCONNECTED);
-            }
-        }
-        $reply = rtrim($reply, CRLF);
-        #echo "> $name: $reply\n";
-        $replyType = substr($reply, 0, 1);
-        switch ($replyType) {
-            /* Error reply */
-            case '-':
-                if($this->isMulti || $this->usePipeline) {
-                    $response = FALSE;
-                } else if ($name == 'evalsha' && substr($reply,0,9) == '-NOSCRIPT') {
-                    $response = NULL;
-                } else {
-                    throw new CredisException(substr($reply,0,4) == '-ERR' ? substr($reply, 5) : substr($reply,1));
-                }
-                break;
-            /* Inline reply */
-            case '+':
-                $response = substr($reply, 1);
-                if($response == 'OK' || $response == 'QUEUED') {
-                  return TRUE;
-                }
-                break;
-            /* Bulk reply */
-            case '$':
-                if ($reply == '$-1') return FALSE;
-                $size = (int) substr($reply, 1);
-                $response = stream_get_contents($this->redis, $size + 2);
-                if( ! $response) {
-                    $this->connected = FALSE;
-                    throw new CredisException('Error reading reply.');
-                }
-                $response = substr($response, 0, $size);
-                break;
-            /* Multi-bulk reply */
-            case '*':
-                $count = substr($reply, 1);
-                if ($count == '-1') return FALSE;
-
-                $response = array();
-                for ($i = 0; $i < $count; $i++) {
-                        $response[] = $this->read_reply();
-                }
-                break;
-            /* Integer reply */
-            case ':':
-                $response = intval(substr($reply, 1));
-                break;
-            default:
-                throw new CredisException('Invalid response: '.print_r($reply, TRUE));
-                break;
-        }
-
-        // Smooth over differences between phpredis and standalone response
-        switch($name)
-        {
-            case '': // Minor optimization for multi-bulk replies
-                break;
-            case 'config':
-            case 'hgetall':
-                $keys = $values = array();
-                while($response) {
-                    $keys[] = array_shift($response);
-                    $values[] = array_shift($response);
-                }
-                $response = count($keys) ? array_combine($keys, $values) : array();
-                break;
-            case 'info':
-                $lines = explode(CRLF, trim($response,CRLF));
-                $response = array();
-                foreach($lines as $line) {
-                    if ( ! $line || substr($line, 0, 1) == '#') {
-                      continue;
-                    }
-                    list($key, $value) = explode(':', $line, 2);
-                    $response[$key] = $value;
-                }
-                break;
-            case 'ttl':
-                if($response === -1) {
-                    $response = FALSE;
-                }
-                break;
-        }
-
-        return $response;
-    }
-
-    /**
-     * Build the Redis unified protocol command
-     *
-     * @param array $args
-     * @return string
-     */
-    private static function _prepare_command($args)
-    {
-        return sprintf('*%d%s%s%s', count($args), CRLF, implode(array_map(array('self', '_map'), $args), CRLF), CRLF);
-    }
-
-    private static function _map($arg)
-    {
-        return sprintf('$%d%s%s', strlen($arg), CRLF, $arg);
-    }
-
-}
diff --git a/vendor/magento/framework/Config/ConfigOptionsListConstants.php b/lib/internal/Magento/Framework/Config/ConfigOptionsListConstants.php
index d7f0229..b636352 100644
--- a/vendor/magento/framework/Config/ConfigOptionsListConstants.php
+++ b/vendor/magento/framework/Config/ConfigOptionsListConstants.php
@@ -56,6 +56,7 @@ class ConfigOptionsListConstants
      */
     const SESSION_SAVE_FILES = 'files';
     const SESSION_SAVE_DB = 'db';
+    const SESSION_SAVE_REDIS = 'redis';
     /**#@-*/
 
     /**
diff --git a/vendor/magento/framework/Session/Config.php b/lib/internal/Magento/Framework/Session/Config.php
index 4fe892a..fafc0e5 100644
--- a/vendor/magento/framework/Session/Config.php
+++ b/vendor/magento/framework/Session/Config.php
@@ -15,8 +15,6 @@ use Magento\Framework\Session\SaveHandlerInterface;
 
 /**
  * Magento session configuration
- *
- * @method Config setSaveHandler()
  */
 class Config implements ConfigInterface
 {
@@ -130,21 +128,6 @@ class Config implements ConfigInterface
         $this->_scopeType = $scopeType;
 
         /**
-         * Session handler
-         *
-         * Save handler may be set to custom value in deployment config, which will override everything else.
-         * Otherwise, try to read PHP settings for session.save_handler value. Otherwise, use 'files' as default.
-         */
-        $defaultSaveHandler = $this->getStorageOption('session.save_handler')
-            ?: SaveHandlerInterface::DEFAULT_HANDLER;
-        $saveMethod = $deploymentConfig->get(
-            self::PARAM_SESSION_SAVE_METHOD,
-            $defaultSaveHandler
-        );
-        $saveMethod = $saveMethod === 'db' ? 'user' : $saveMethod;
-        $this->setSaveHandler($saveMethod);
-
-        /**
          * Session path
          */
         $savePath = $deploymentConfig->get(self::PARAM_SESSION_SAVE_PATH);
diff --git a/vendor/magento/framework/Session/SaveHandler.php b/lib/internal/Magento/Framework/Session/SaveHandler.php
index 5fedbac..8680eb0 100644
--- a/vendor/magento/framework/Session/SaveHandler.php
+++ b/vendor/magento/framework/Session/SaveHandler.php
@@ -5,8 +5,10 @@
  */
 namespace Magento\Framework\Session;
 
-use Magento\Framework\App\DeploymentConfig;
+use Magento\Framework\Session\Config;
+use Magento\Framework\Session\Config\ConfigInterface;
 use Magento\Framework\Exception\SessionException;
+use Magento\Framework\App\DeploymentConfig;
 
 /**
  * Magento session save handler
@@ -21,6 +23,18 @@ class SaveHandler implements SaveHandlerInterface
     protected $saveHandlerAdapter;
 
     /**
+     * Config
+     *
+     * @var ConfigInterface
+     */
+    private $config;
+
+    /**
+     * @var string
+     */
+    private $saveHandlerName;
+
+    /**
      * Constructor
      *
      * @param SaveHandlerFactory $saveHandlerFactory
@@ -32,11 +46,21 @@ class SaveHandler implements SaveHandlerInterface
         DeploymentConfig $deploymentConfig,
         $default = self::DEFAULT_HANDLER
     ) {
-        $saveMethod = $deploymentConfig->get(\Magento\Framework\Session\Config::PARAM_SESSION_SAVE_METHOD);
+        /**
+         * Session handler
+         *
+         * Save handler may be set to custom value in deployment config, which will override everything else.
+         * Otherwise, try to read PHP settings for session.save_handler value. Otherwise, use 'files' as default.
+         */
+        $defaultSaveHandler = ini_get('session.save_handler') ?: SaveHandlerInterface::DEFAULT_HANDLER;
+        $saveMethod = $deploymentConfig->get(Config::PARAM_SESSION_SAVE_METHOD, $defaultSaveHandler);
+        $this->setSaveHandler($saveMethod);
+
         try {
             $connection = $saveHandlerFactory->create($saveMethod);
         } catch (SessionException $e) {
             $connection = $saveHandlerFactory->create($default);
+            $this->setSaveHandler($default);
         }
         $this->saveHandlerAdapter = $connection;
     }
@@ -109,4 +133,32 @@ class SaveHandler implements SaveHandlerInterface
     {
         return $this->saveHandlerAdapter->gc($maxLifetime);
     }
+
+    /**
+     * Get config
+     *
+     * @return ConfigInterface
+     * @deprecated
+     */
+    private function getConfig()
+    {
+        if (!($this->config instanceof ConfigInterface)) {
+            return \Magento\Framework\App\ObjectManager::getInstance()->get(
+                ConfigInterface::class
+            );
+        }
+        return $this->config;
+    }
+
+    /**
+     * {@inheritdoc}
+     */
+    private function setSaveHandler($saveHandler)
+    {
+        if ($saveHandler === 'db' || $saveHandler === 'redis') {
+            $saveHandler = 'user';
+        }
+        $this->getConfig()->setOption('session.save_handler', $saveHandler);
+        return $this;
+    }
 }
diff --git a/vendor/magento/framework/Session/SaveHandler/Redis.php b/lib/internal/Magento/Framework/Session/SaveHandler/Redis.php
new file mode 100644
index 0000000..56ce5cc
--- /dev/null
+++ b/vendor/magento/framework/Session/SaveHandler/Redis.php
@@ -0,0 +1,51 @@
+<?php
+/**
+ * Copyright Â© 2015 Magento. All rights reserved.
+ * See COPYING.txt for license details.
+ */
+namespace Magento\Framework\Session\SaveHandler;
+
+use Cm\RedisSession\Handler\ConfigInterface;
+use Cm\RedisSession\Handler\LoggerInterface;
+use Cm\RedisSession\ConnectionFailedException;
+use Cm\RedisSession\ConcurrentConnectionsExceededException;
+use Magento\Framework\Exception\SessionException;
+use Magento\Framework\Phrase;
+use Magento\Framework\Filesystem;
+use Magento\Framework\App\Filesystem\DirectoryList;
+
+class Redis extends \Cm\RedisSession\Handler
+{
+    /**
+     * @var Filesystem
+     */
+    private $filesystem;
+
+    /**
+     * @param ConfigInterface $config
+     * @param LoggerInterface $logger
+     * @param Filesystem $filesystem
+     * @throws SessionException
+     */
+    public function __construct(ConfigInterface $config, LoggerInterface $logger, Filesystem $filesystem)
+    {
+        $this->filesystem = $filesystem;
+        try {
+            parent::__construct($config, $logger);
+        } catch (ConnectionFailedException $e) {
+            throw new SessionException(new Phrase($e->getMessage()));
+        }
+    }
+
+    /**
+     * {@inheritdoc}
+     */
+    public function read($sessionId)
+    {
+        try {
+            return parent::read($sessionId);
+        } catch (ConcurrentConnectionsExceededException $e) {
+            require $this->filesystem->getDirectoryRead(DirectoryList::PUB)->getAbsolutePath('errors/503.php');
+        }
+    }
+}
diff --git a/vendor/magento/framework/Session/SaveHandler/Redis/Config.php b/lib/internal/Magento/Framework/Session/SaveHandler/Redis/Config.php
new file mode 100644
index 0000000..172431b
--- /dev/null
+++ b/vendor/magento/framework/Session/SaveHandler/Redis/Config.php
@@ -0,0 +1,291 @@
+<?php
+/**
+ * Copyright Â© 2015 Magento. All rights reserved.
+ * See COPYING.txt for license details.
+ */
+namespace Magento\Framework\Session\SaveHandler\Redis;
+
+use Magento\Framework\App\Config\ScopeConfigInterface;
+use Magento\Store\Model\ScopeInterface as StoreScopeInterface;
+use Magento\Framework\App\DeploymentConfig;
+use Magento\Framework\App\State;
+
+/**
+ * Redis session save handler
+ */
+class Config implements \Cm\RedisSession\Handler\ConfigInterface
+{
+    /**
+     * Configuration path for log level
+     */
+    const PARAM_LOG_LEVEL               = 'session/redis/log_level';
+
+    /**
+     * Configuration path for host
+     */
+    const PARAM_HOST                    = 'session/redis/host';
+
+    /**
+     * Configuration path for port
+     */
+    const PARAM_PORT                    = 'session/redis/port';
+
+    /**
+     * Configuration path for database
+     */
+    const PARAM_DATABASE                = 'session/redis/database';
+
+    /**
+     * Configuration path for password
+     */
+    const PARAM_PASSWORD                = 'session/redis/password';
+
+    /**
+     * Configuration path for connection timeout
+     */
+    const PARAM_TIMEOUT                 = 'session/redis/timeout';
+
+    /**
+     * Configuration path for persistent identifier
+     */
+    const PARAM_PERSISTENT_IDENTIFIER   = 'session/redis/param_persistent_identifier';
+
+    /**
+     * Configuration path for compression threshold
+     */
+    const PARAM_COMPRESSION_THRESHOLD   = 'session/redis/param_compression_threshold';
+
+    /**
+     * Configuration path for compression library
+     */
+    const PARAM_COMPRESSION_LIBRARY     = 'session/redis/compression_library';
+
+    /**
+     * Configuration path for maximum number of processes that can wait for a lock on one session
+     */
+    const PARAM_MAX_CONCURRENCY         = 'session/redis/max_concurrency';
+
+    /**
+     * Configuration path for minimum session lifetime
+     */
+    const PARAM_MAX_LIFETIME            = 'session/redis/max_lifetime';
+
+    /**
+     * Configuration path for min
+     */
+    const PARAM_MIN_LIFETIME            = 'session/redis/min_lifetime';
+
+    /**
+     * Configuration path for disabling session locking entirely flag
+     */
+    const PARAM_DISABLE_LOCKING         = 'session/redis/disable_locking';
+
+    /**
+     * Configuration path for lifetime of session for bots on subsequent writes
+     */
+    const PARAM_BOT_LIFETIME            = 'session/redis/bot_lifetime';
+
+    /**
+     * Configuration path for lifetime of session for bots on the first write
+     */
+    const PARAM_BOT_FIRST_LIFETIME      = 'session/redis/bot_first_lifetime';
+
+    /**
+     * Configuration path for lifetime of session for non-bots on the first write
+     */
+    const PARAM_FIRST_LIFETIME          = 'session/redis/first_lifetime';
+
+    /**
+     * Configuration path for number of seconds to wait before trying to break the lock
+     */
+    const PARAM_BREAK_AFTER             = 'session/redis/break_after';
+
+    /**
+     * Cookie lifetime config path
+     */
+    const XML_PATH_COOKIE_LIFETIME = 'web/cookie/cookie_lifetime';
+
+    /**
+     * Admin session lifetime config path
+     */
+    const XML_PATH_ADMIN_SESSION_LIFETIME = 'admin/security/session_lifetime';
+
+    /**
+     * Session max lifetime
+     */
+    const SESSION_MAX_LIFETIME = 31536000;
+
+    /**
+     * Deployment config
+     *
+     * @var DeploymentConfig $deploymentConfig
+     */
+    private $deploymentConfig;
+
+    /**
+     * @var ScopeConfigInterface
+     */
+    private $scopeConfig;
+
+    /**
+     * @param DeploymentConfig $deploymentConfig
+     * @param State $appState
+     * @param ScopeConfigInterface $scopeConfig
+     */
+    public function __construct(
+        DeploymentConfig $deploymentConfig,
+        State $appState,
+        ScopeConfigInterface $scopeConfig
+    ) {
+        $this->deploymentConfig = $deploymentConfig;
+        $this->appState = $appState;
+        $this->scopeConfig = $scopeConfig;
+    }
+
+    /**
+     * {@inheritdoc}
+     */
+    public function getLogLevel()
+    {
+        return $this->deploymentConfig->get(self::PARAM_LOG_LEVEL);
+    }
+
+    /**
+     * {@inheritdoc}
+     */
+    public function getHost()
+    {
+        return $this->deploymentConfig->get(self::PARAM_HOST);
+    }
+
+    /**
+     * {@inheritdoc}
+     */
+    public function getPort()
+    {
+        return $this->deploymentConfig->get(self::PARAM_PORT);
+    }
+
+    /**
+     * {@inheritdoc}
+     */
+    public function getDatabase()
+    {
+        return $this->deploymentConfig->get(self::PARAM_DATABASE);
+    }
+
+    /**
+     * {@inheritdoc}
+     */
+    public function getPassword()
+    {
+        return $this->deploymentConfig->get(self::PARAM_PASSWORD);
+    }
+
+    /**
+     * {@inheritdoc}
+     */
+    public function getTimeout()
+    {
+        return $this->deploymentConfig->get(self::PARAM_TIMEOUT);
+    }
+
+    /**
+     * {@inheritdoc}
+     */
+    public function getPersistentIdentifier()
+    {
+        return $this->deploymentConfig->get(self::PARAM_PERSISTENT_IDENTIFIER);
+    }
+
+    /**
+     * {@inheritdoc}
+     */
+    public function getCompressionThreshold()
+    {
+        return $this->deploymentConfig->get(self::PARAM_COMPRESSION_THRESHOLD);
+    }
+
+    /**
+     * {@inheritdoc}
+     */
+    public function getCompressionLibrary()
+    {
+        return $this->deploymentConfig->get(self::PARAM_COMPRESSION_LIBRARY);
+    }
+
+    /**
+     * {@inheritdoc}
+     */
+    public function getMaxConcurrency()
+    {
+        return $this->deploymentConfig->get(self::PARAM_MAX_CONCURRENCY);
+    }
+
+    /**
+     * {@inheritdoc}
+     */
+    public function getMaxLifetime()
+    {
+        return self::SESSION_MAX_LIFETIME;
+    }
+
+    /**
+     * {@inheritdoc}
+     */
+    public function getMinLifetime()
+    {
+        return $this->deploymentConfig->get(self::PARAM_MIN_LIFETIME);
+    }
+
+    /**
+     * {@inheritdoc}
+     */
+    public function getDisableLocking()
+    {
+        return $this->deploymentConfig->get(self::PARAM_DISABLE_LOCKING);
+    }
+
+    /**
+     * {@inheritdoc}
+     */
+    public function getBotLifetime()
+    {
+        return $this->deploymentConfig->get(self::PARAM_BOT_LIFETIME);
+    }
+
+    /**
+     * {@inheritdoc}
+     */
+    public function getBotFirstLifetime()
+    {
+        return $this->deploymentConfig->get(self::PARAM_BOT_FIRST_LIFETIME);
+    }
+
+    /**
+     * {@inheritdoc}
+     */
+    public function getFirstLifetime()
+    {
+        return $this->deploymentConfig->get(self::PARAM_FIRST_LIFETIME);
+    }
+
+    /**
+     * {@inheritdoc}
+     */
+    public function getBreakAfter()
+    {
+        return $this->deploymentConfig->get(self::PARAM_BREAK_AFTER . '_' . $this->appState->getAreaCode());
+    }
+
+    /**
+     * {@inheritdoc}
+     */
+    public function getLifetime()
+    {
+        if ($this->appState->getAreaCode() == \Magento\Framework\App\Area::AREA_ADMINHTML) {
+            return (int)$this->scopeConfig->getValue(self::XML_PATH_ADMIN_SESSION_LIFETIME);
+        }
+        return (int)$this->scopeConfig->getValue(self::XML_PATH_COOKIE_LIFETIME, StoreScopeInterface::SCOPE_STORE);
+    }
+}
diff --git a/vendor/magento/framework/Session/SaveHandler/Redis/Logger.php b/lib/internal/Magento/Framework/Session/SaveHandler/Redis/Logger.php
new file mode 100644
index 0000000..8684f47
--- /dev/null
+++ b/vendor/magento/framework/Session/SaveHandler/Redis/Logger.php
@@ -0,0 +1,93 @@
+<?php
+/**
+ * Copyright Â© 2015 Magento. All rights reserved.
+ * See COPYING.txt for license details.
+ */
+namespace Magento\Framework\Session\SaveHandler\Redis;
+
+use Cm\RedisSession\Handler\ConfigInterface;
+use Psr\Log\LoggerInterface;
+use Magento\Framework\App\Request\Http as Request;
+
+class Logger implements \Cm\RedisSession\Handler\LoggerInterface
+{
+    /**
+     * @var LoggerInterface
+     */
+    private $logger;
+
+    /**
+     * @var int
+     */
+    private $logLevel;
+
+    /**
+     * @var Request
+     */
+    private $request;
+
+    /**
+     * Logger constructor
+     *
+     * @param ConfigInterface $config
+     * @param LoggerInterface $logger
+     * @param Request $request
+     */
+    public function __construct(ConfigInterface $config, LoggerInterface $logger, Request $request)
+    {
+        $this->logger = $logger;
+        $this->request = $request;
+        $this->logLevel = $config->getLogLevel() ?: self::ALERT;
+    }
+
+    /**
+     * {@inheritdoc}
+     */
+    public function setLogLevel($level)
+    {
+        $this->logLevel = $level;
+    }
+
+    /**
+     * {@inheritdoc}
+     */
+    public function log($message, $level)
+    {
+        $message .= ' ' . $this->request->getRequestUri();
+        if ($this->logLevel >= $level) {
+            switch ($level) {
+                case self::EMERGENCY:
+                    $this->logger->emergency($message);
+                    break;
+                case self::ALERT:
+                    $this->logger->alert($message);
+                    break;
+                case self::CRITICAL:
+                    $this->logger->critical($message);
+                    break;
+                case self::ERROR:
+                    $this->logger->error($message);
+                    break;
+                case self::WARNING:
+                    $this->logger->warning($message);
+                    break;
+                case self::NOTICE:
+                    $this->logger->notice($message);
+                    break;
+                case self::INFO:
+                    $this->logger->info($message);
+                    break;
+                default:
+                    $this->logger->debug($message);
+            }
+        }
+    }
+
+    /**
+     * {@inheritdoc}
+     */
+    public function logException(\Exception $e)
+    {
+        $this->logger->critical($e->getMessage());
+    }
+}
diff --git a/vendor/magento/framework/Session/Test/Unit/ConfigTest.php b/lib/internal/Magento/Framework/Session/Test/Unit/ConfigTest.php
index 5698d1a..2940db7 100644
--- a/vendor/magento/framework/Session/Test/Unit/ConfigTest.php
+++ b/vendor/magento/framework/Session/Test/Unit/ConfigTest.php
@@ -15,9 +15,6 @@ use \Magento\Framework\Session\Config;
 
 class ConfigTest extends \PHPUnit_Framework_TestCase
 {
-    /** mock session.save_handler value from deployment config */
-    const SESSION_HANDLER_CONFIG = 'files';
-
     /**
      * @var \Magento\Framework\TestFramework\Unit\Helper\ObjectManager
      */
@@ -89,7 +86,6 @@ class ConfigTest extends \PHPUnit_Framework_TestCase
         return [
             ['save_path', 'getSavePath', __DIR__],
             ['name', 'getName', 'FOOBAR'],
-            ['save_handler', 'getSaveHandler', 'user'],
             ['gc_probability', 'getGcProbability', 42],
             ['gc_divisor', 'getGcDivisor', 3],
             ['gc_maxlifetime', 'getGcMaxlifetime', 180],
@@ -135,23 +131,6 @@ class ConfigTest extends \PHPUnit_Framework_TestCase
         $this->assertEquals('FOOBAR', $this->config->getName());
     }
 
-    public function testSaveHandlerFromConfig()
-    {
-        $this->getModel($this->validatorMock);
-        $this->assertSame(
-            self::SESSION_HANDLER_CONFIG,
-            $this->config->getSaveHandler(),
-            var_export($this->config->toArray(), 1)
-        );
-    }
-
-    public function testSaveHandlerIsMutable()
-    {
-        $this->getModel($this->validatorMock);
-        $this->config->setSaveHandler('user');
-        $this->assertEquals('user', $this->config->getSaveHandler());
-    }
-
     public function testCookieLifetimeIsMutable()
     {
         $this->getModel($this->validatorMock);
@@ -370,7 +349,6 @@ class ConfigTest extends \PHPUnit_Framework_TestCase
                 true,
                 true,
                 [
-                    'session.save_handler' => 'files',
                     'session.cache_limiter' => 'files',
                     'session.cookie_lifetime' => 7200,
                     'session.cookie_path' => '/',
@@ -382,7 +360,6 @@ class ConfigTest extends \PHPUnit_Framework_TestCase
                 true,
                 false,
                 [
-                    'session.save_handler' => 'files',
                     'session.cache_limiter' => 'files',
                     'session.cookie_httponly' => false,
                 ],
@@ -391,7 +368,6 @@ class ConfigTest extends \PHPUnit_Framework_TestCase
                 false,
                 true,
                 [
-                    'session.save_handler' => 'files',
                     'session.cache_limiter' => 'files',
                     'session.cookie_lifetime' => 3600,
                     'session.cookie_path' => '/',
@@ -454,13 +430,9 @@ class ConfigTest extends \PHPUnit_Framework_TestCase
         $deploymentConfigMock = $this->getMock('Magento\Framework\App\DeploymentConfig', [], [], '', false);
         $deploymentConfigMock->expects($this->at(0))
             ->method('get')
-            ->with(Config::PARAM_SESSION_SAVE_METHOD, ini_get('session.save_handler') ?: 'files')
-            ->willReturn(self::SESSION_HANDLER_CONFIG);
-        $deploymentConfigMock->expects($this->at(1))
-            ->method('get')
             ->with(Config::PARAM_SESSION_SAVE_PATH)
             ->will($this->returnValue(null));
-        $deploymentConfigMock->expects($this->at(2))
+        $deploymentConfigMock->expects($this->at(1))
             ->method('get')
             ->with(Config::PARAM_SESSION_CACHE_LIMITER)
             ->will($this->returnValue('files'));
@@ -471,13 +443,12 @@ class ConfigTest extends \PHPUnit_Framework_TestCase
                 'scopeConfig' => $this->configMock,
                 'validatorFactory' => $this->validatorFactoryMock,
                 'scopeType' => \Magento\Store\Model\ScopeInterface::SCOPE_STORE,
-                'cacheLimiter' => \Magento\Framework\Session\SaveHandlerInterface::DEFAULT_HANDLER,
+                'cacheLimiter' => 'files',
                 'lifetimePath' => 'test_web/test_cookie/test_cookie_lifetime',
                 'request' => $this->requestMock,
                 'filesystem' => $filesystemMock,
                 'deploymentConfig' => $deploymentConfigMock,
             ]
-
         );
         return $this->config;
     }
diff --git a/vendor/magento/framework/Session/Test/Unit/SaveHandler/Redis/ConfigTest.php b/lib/internal/Magento/Framework/Session/Test/Unit/SaveHandler/Redis/ConfigTest.php
new file mode 100644
index 0000000..de65444
--- /dev/null
+++ b/vendor/magento/framework/Session/Test/Unit/SaveHandler/Redis/ConfigTest.php
@@ -0,0 +1,249 @@
+<?php
+/**
+ * Copyright Â© 2015 Magento. All rights reserved.
+ * See COPYING.txt for license details.
+ */
+namespace Magento\Framework\Session\Test\Unit\SaveHandler\Redis;
+
+use Magento\Store\Model\ScopeInterface;
+use Magento\Framework\Session\SaveHandler\Redis\Config;
+
+class ConfigTest extends \PHPUnit_Framework_TestCase
+{
+    /**
+     * @var \Magento\Framework\App\DeploymentConfig|\PHPUnit_Framework_MockObject_MockObject
+     */
+    private $deploymentConfigMock;
+
+    /**
+     * @var \Magento\Framework\App\State|\PHPUnit_Framework_MockObject_MockObject
+     */
+    private $appStateMock;
+
+    /**
+     * @var \Magento\Framework\App\Config|\PHPUnit_Framework_MockObject_MockObject
+     */
+    private $scopeConfigMock;
+
+    /**
+     * @var Config
+     */
+    private $config;
+
+    public function setUp()
+    {
+        $this->deploymentConfigMock = $this->getMock(\Magento\Framework\App\DeploymentConfig::class, [], [], '', false);
+        $this->appStateMock = $this->getMock(\Magento\Framework\App\State::class, [], [], '', false);
+        $this->scopeConfigMock = $this->getMock(\Magento\Framework\App\Config::class, [], [], '', false);
+
+        $objectManager = new \Magento\Framework\TestFramework\Unit\Helper\ObjectManager($this);
+        $this->config = $objectManager->getObject(
+            Config::class,
+            [
+                'deploymentConfig' => $this->deploymentConfigMock,
+                'appState' => $this->appStateMock,
+                'scopeConfig' => $this->scopeConfigMock
+            ]
+        );
+    }
+
+    public function testGetLogLevel()
+    {
+        $expected = 2;
+        $this->deploymentConfigMock->expects($this->once())
+            ->method('get')
+            ->with(Config::PARAM_LOG_LEVEL)
+            ->willReturn($expected);
+        $this->assertEquals($this->config->getLogLevel(), $expected);
+    }
+
+    public function testGetHost()
+    {
+        $expected = '127.0.0.1';
+        $this->deploymentConfigMock->expects($this->once())
+            ->method('get')
+            ->with(Config::PARAM_HOST)
+            ->willReturn($expected);
+        $this->assertEquals($this->config->getHost(), $expected);
+    }
+
+    public function testGetPort()
+    {
+        $expected = 1234;
+        $this->deploymentConfigMock->expects($this->once())
+            ->method('get')
+            ->with(Config::PARAM_PORT)
+            ->willReturn($expected);
+        $this->assertEquals($this->config->getPort(), $expected);
+    }
+
+    public function testGetDatabase()
+    {
+        $expected = 2;
+        $this->deploymentConfigMock->expects($this->once())
+            ->method('get')
+            ->with(Config::PARAM_DATABASE)
+            ->willReturn($expected);
+        $this->assertEquals($this->config->getDatabase(), $expected);
+    }
+
+    public function testGetPassword()
+    {
+        $expected = 'password';
+        $this->deploymentConfigMock->expects($this->once())
+            ->method('get')
+            ->with(Config::PARAM_PASSWORD)
+            ->willReturn($expected);
+        $this->assertEquals($this->config->getPassword(), $expected);
+    }
+
+    public function testGetTimeout()
+    {
+        $expected = 10;
+        $this->deploymentConfigMock->expects($this->once())
+            ->method('get')
+            ->with(Config::PARAM_TIMEOUT)
+            ->willReturn($expected);
+        $this->assertEquals($this->config->getTimeout(), $expected);
+    }
+
+    public function testGetPersistentIdentifier()
+    {
+        $expected = 'sess01';
+        $this->deploymentConfigMock->expects($this->once())
+            ->method('get')
+            ->with(Config::PARAM_PERSISTENT_IDENTIFIER)
+            ->willReturn($expected);
+        $this->assertEquals($this->config->getPersistentIdentifier(), $expected);
+    }
+
+    public function testGetCompressionThreshold()
+    {
+        $expected = 2;
+        $this->deploymentConfigMock->expects($this->once())
+            ->method('get')
+            ->with(Config::PARAM_COMPRESSION_THRESHOLD)
+            ->willReturn($expected);
+        $this->assertEquals($this->config->getCompressionThreshold(), $expected);
+    }
+
+    public function testGetCompressionLibrary()
+    {
+        $expected = 'gzip';
+        $this->deploymentConfigMock->expects($this->once())
+            ->method('get')
+            ->with(Config::PARAM_COMPRESSION_LIBRARY)
+            ->willReturn($expected);
+        $this->assertEquals($this->config->getCompressionLibrary(), $expected);
+    }
+
+    public function testGetMaxConcurrency()
+    {
+        $expected = 6;
+        $this->deploymentConfigMock->expects($this->once())
+            ->method('get')
+            ->with(Config::PARAM_MAX_CONCURRENCY)
+            ->willReturn($expected);
+        $this->assertEquals($this->config->getMaxConcurrency(), $expected);
+    }
+
+    public function testGetMaxLifetime()
+    {
+        $this->assertEquals($this->config->getMaxLifetime(), Config::SESSION_MAX_LIFETIME);
+    }
+
+    public function testGetMinLifetime()
+    {
+        $expected = 30;
+        $this->deploymentConfigMock->expects($this->once())
+            ->method('get')
+            ->with(Config::PARAM_MIN_LIFETIME)
+            ->willReturn($expected);
+        $this->assertEquals($this->config->getMinLifetime(), $expected);
+    }
+
+    public function testGetDisableLocking()
+    {
+        $expected = false;
+        $this->deploymentConfigMock->expects($this->once())
+            ->method('get')
+            ->with(Config::PARAM_DISABLE_LOCKING)
+            ->willReturn($expected);
+        $this->assertEquals($this->config->getDisableLocking(), $expected);
+    }
+
+    public function testGetBotLifetime()
+    {
+        $expected = 30;
+        $this->deploymentConfigMock->expects($this->once())
+            ->method('get')
+            ->with(Config::PARAM_BOT_LIFETIME)
+            ->willReturn($expected);
+        $this->assertEquals($this->config->getBotLifetime(), $expected);
+    }
+
+    public function testGetBotFirstLifetime()
+    {
+        $expected = 30;
+        $this->deploymentConfigMock->expects($this->once())
+            ->method('get')
+            ->with(Config::PARAM_BOT_FIRST_LIFETIME)
+            ->willReturn($expected);
+        $this->assertEquals($this->config->getBotFirstLifetime(), $expected);
+    }
+
+    public function testGetFirstLifetime()
+    {
+        $expected = 30;
+        $this->deploymentConfigMock->expects($this->once())
+            ->method('get')
+            ->with(Config::PARAM_FIRST_LIFETIME)
+            ->willReturn($expected);
+        $this->assertEquals($this->config->getFirstLifetime(), $expected);
+    }
+
+    public function testBreakAfter()
+    {
+        $areaCode = 'frontend';
+        $breakAfter = 5;
+        $this->deploymentConfigMock->expects($this->once())
+            ->method('get')
+            ->with(Config::PARAM_BREAK_AFTER . '_' . $areaCode)
+            ->willReturn($breakAfter);
+        $this->appStateMock->expects($this->once())
+            ->method('getAreaCode')
+            ->willReturn($areaCode);
+        $this->assertEquals($this->config->getBreakAfter(), $breakAfter);
+    }
+
+    public function testGetLifetimeAdmin()
+    {
+        $areaCode = 'adminhtml';
+        $expectedLifetime = 123;
+        $this->appStateMock->expects($this->once())
+            ->method('getAreaCode')
+            ->willReturn($areaCode);
+        $this->scopeConfigMock->expects($this->once())
+            ->method('getValue')
+            ->with(Config::XML_PATH_ADMIN_SESSION_LIFETIME)
+            ->willReturn($expectedLifetime);
+        $this->assertEquals($this->config->getLifetime(), $expectedLifetime);
+    }
+
+    public function testGetLifetimeFrontend()
+    {
+        $areaCode = 'frontend';
+        $expectedLifetime = 234;
+        $this->appStateMock->expects($this->once())
+            ->method('getAreaCode')
+            ->willReturn($areaCode);
+        $this->scopeConfigMock->expects($this->once())
+            ->method('getValue')
+            ->with(
+                Config::XML_PATH_COOKIE_LIFETIME,
+                ScopeInterface::SCOPE_STORE
+            )
+            ->willReturn($expectedLifetime);
+        $this->assertEquals($this->config->getLifetime(), $expectedLifetime);
+    }
+}
diff --git a/vendor/magento/framework/Session/Test/Unit/SaveHandler/Redis/LoggerTest.php b/lib/internal/Magento/Framework/Session/Test/Unit/SaveHandler/Redis/LoggerTest.php
new file mode 100644
index 0000000..d48bea6
--- /dev/null
+++ b/vendor/magento/framework/Session/Test/Unit/SaveHandler/Redis/LoggerTest.php
@@ -0,0 +1,95 @@
+<?php
+/**
+ * Copyright Â© 2015 Magento. All rights reserved.
+ * See COPYING.txt for license details.
+ */
+namespace Magento\Framework\Session\Test\Unit\SaveHandler\Redis;
+
+use Cm\RedisSession\Handler\LoggerInterface;
+use Magento\Framework\Session\SaveHandler\Redis\Logger;
+
+class LoggerTest extends \PHPUnit_Framework_TestCase
+{
+    /**
+     * @var \Cm\RedisSession\Handler\ConfigInterface
+     */
+    protected $config;
+
+    /**
+     * @var \Psr\Log\LoggerInterface
+     */
+    protected $psrLogger;
+
+    /**
+     * @var \Magento\Framework\Session\SaveHandler\Redis\Logger
+     */
+    protected $logger;
+
+    /**
+     * @var \Magento\Framework\App\Request\Http
+     */
+    protected $request;
+
+    /**
+     * @var string
+     */
+    protected $requestUri = 'customer/account/login';
+
+    public function setUp()
+    {
+        $this->config = $this->getMock('Cm\RedisSession\Handler\ConfigInterface', [], [], '', false);
+        $this->config->expects($this->once())
+            ->method('getLogLevel')
+            ->willReturn(LoggerInterface::DEBUG);
+        $this->psrLogger = $this->getMock('Psr\Log\LoggerInterface', [], [], '', false);
+        $this->request = $this->getMock('Magento\Framework\App\Request\Http', [], [], '', false);
+        //$this->logger = new Logger($this->config, $this->psrLogger, $this->request);
+        $objectManager = new \Magento\Framework\TestFramework\Unit\Helper\ObjectManager($this);
+        $this->logger = $objectManager->getObject(
+            'Magento\Framework\Session\SaveHandler\Redis\Logger',
+            [
+                'config' => $this->config,
+                'logger' => $this->psrLogger,
+                'request' => $this->request
+            ]
+        );
+    }
+
+    /**
+     * @dataProvider logDataProvider
+     */
+    public function testLog($logLevel, $method)
+    {
+        $message = 'Error message';
+        $this->request->expects($this->once())
+            ->method('getRequestUri')
+            ->willReturn($this->requestUri);
+        $this->psrLogger->expects($this->once())
+            ->method($method)
+            ->with($message . ' ' . $this->requestUri);
+        $this->logger->log($message, $logLevel);
+    }
+
+    public function logDataProvider()
+    {
+        return [
+            [LoggerInterface::EMERGENCY, 'emergency'],
+            [LoggerInterface::ALERT, 'alert'],
+            [LoggerInterface::CRITICAL, 'critical'],
+            [LoggerInterface::ERROR, 'error'],
+            [LoggerInterface::WARNING, 'warning'],
+            [LoggerInterface::NOTICE, 'notice'],
+            [LoggerInterface::INFO, 'info'],
+            [LoggerInterface::DEBUG, 'debug'],
+        ];
+    }
+
+    public function testLogException()
+    {
+        $exception = new \Exception('Error message');
+        $this->psrLogger->expects($this->once())
+            ->method('critical')
+            ->with($exception->getMessage());
+        $this->logger->logException($exception);
+    }
+}
diff --git a/setup/src/Magento/Setup/Test/Unit/Model/ConfigOptionsListTest.php b/setup/src/Magento/Setup/Test/Unit/Model/ConfigOptionsListTest.php
new file mode 100644
index 0000000..b961e3f0
--- /dev/null
+++ b/setup/src/Magento/Setup/Test/Unit/Model/ConfigOptionsListTest.php
@@ -0,0 +1,185 @@
+<?php
+/**
+ * Copyright Â© 2016 Magento. All rights reserved.
+ * See COPYING.txt for license details.
+ */
+
+namespace Magento\Setup\Test\Unit\Model;
+
+use Magento\Setup\Model\ConfigGenerator;
+use Magento\Setup\Model\ConfigOptionsList;
+use Magento\Setup\Validator\DbValidator;
+use Magento\Framework\Config\ConfigOptionsListConstants;
+
+class ConfigOptionsListTest extends \PHPUnit_Framework_TestCase
+{
+    /**
+     * @var ConfigOptionsList
+     */
+    private $object;
+
+    /**
+     * @var ConfigGenerator|\PHPUnit_Framework_MockObject_MockObject
+     */
+    private $generator;
+
+    /**
+     * @var \PHPUnit_Framework_MockObject_MockObject|\Magento\Framework\App\DeploymentConfig
+     */
+    private $deploymentConfig;
+
+    /**
+     * @var DbValidator|\PHPUnit_Framework_MockObject_MockObject
+     */
+    private $dbValidator;
+
+    protected function setUp()
+    {
+        $this->generator = $this->getMock('Magento\Setup\Model\ConfigGenerator', [], [], '', false);
+        $this->deploymentConfig = $this->getMock('Magento\Framework\App\DeploymentConfig', [], [], '', false);
+        $this->dbValidator = $this->getMock('Magento\Setup\Validator\DbValidator', [], [], '', false);
+        $this->object = new ConfigOptionsList($this->generator, $this->dbValidator);
+    }
+
+    public function testGetOptions()
+    {
+        $options = $this->object->getOptions();
+        $this->assertInstanceOf('Magento\Framework\Setup\Option\TextConfigOption', $options[0]);
+        $this->assertSame('Encryption key', $options[0]->getDescription());
+        $this->assertInstanceOf('Magento\Framework\Setup\Option\SelectConfigOption', $options[1]);
+        $this->assertSame('Session save handler', $options[1]->getDescription());
+        $this->assertInstanceOf('Magento\Framework\Setup\Option\SelectConfigOption', $options[2]);
+        $this->assertSame('Type of definitions used by Object Manager', $options[2]->getDescription());
+        $this->assertInstanceOf('Magento\Framework\Setup\Option\TextConfigOption', $options[3]);
+        $this->assertSame('Database server host', $options[3]->getDescription());
+        $this->assertInstanceOf('Magento\Framework\Setup\Option\TextConfigOption', $options[4]);
+        $this->assertSame('Database name', $options[4]->getDescription());
+        $this->assertInstanceOf('Magento\Framework\Setup\Option\TextConfigOption', $options[5]);
+        $this->assertSame('Database server username', $options[5]->getDescription());
+        $this->assertInstanceOf('Magento\Framework\Setup\Option\TextConfigOption', $options[6]);
+        $this->assertSame('Database server engine', $options[6]->getDescription());
+        $this->assertInstanceOf('Magento\Framework\Setup\Option\TextConfigOption', $options[7]);
+        $this->assertSame('Database server password', $options[7]->getDescription());
+        $this->assertInstanceOf('Magento\Framework\Setup\Option\TextConfigOption', $options[8]);
+        $this->assertSame('Database table prefix', $options[8]->getDescription());
+        $this->assertInstanceOf('Magento\Framework\Setup\Option\TextConfigOption', $options[9]);
+        $this->assertSame('Database type', $options[9]->getDescription());
+        $this->assertInstanceOf('Magento\Framework\Setup\Option\TextConfigOption', $options[10]);
+        $this->assertSame('Database  initial set of commands', $options[10]->getDescription());
+        $this->assertInstanceOf('Magento\Framework\Setup\Option\FlagConfigOption', $options[11]);
+        $this->assertSame(
+            'If specified, then db connection validation will be skipped',
+            $options[11]->getDescription()
+        );
+        $this->assertInstanceOf('Magento\Framework\Setup\Option\TextConfigOption', $options[12]);
+        $this->assertSame('http Cache hosts', $options[12]->getDescription());
+        $this->assertEquals(13, count($options));
+    }
+
+    public function testCreateOptions()
+    {
+        $configDataMock = $this->getMock('Magento\Framework\Config\Data\ConfigData', [], [], '', false);
+        $this->generator->expects($this->once())->method('createInstallConfig')->willReturn($configDataMock);
+        $this->generator->expects($this->once())->method('createCryptConfig')->willReturn($configDataMock);
+        $this->generator->expects($this->once())->method('createSessionConfig')->willReturn($configDataMock);
+        $this->generator->expects($this->once())->method('createDefinitionsConfig')->willReturn($configDataMock);
+        $this->generator->expects($this->once())->method('createDbConfig')->willReturn($configDataMock);
+        $this->generator->expects($this->once())->method('createResourceConfig')->willReturn($configDataMock);
+        $this->generator->expects($this->once())->method('createXFrameConfig')->willReturn($configDataMock);
+        $this->generator->expects($this->once())->method('createCacheHostsConfig')->willReturn($configDataMock);
+        $configData = $this->object->createConfig([], $this->deploymentConfig);
+        $this->assertEquals(9, count($configData));
+    }
+
+    public function testCreateOptionsWithOptionalNull()
+    {
+        $configDataMock = $this->getMock('Magento\Framework\Config\Data\ConfigData', [], [], '', false);
+        $this->generator->expects($this->once())->method('createInstallConfig')->willReturn($configDataMock);
+        $this->generator->expects($this->once())->method('createCryptConfig')->willReturn($configDataMock);
+        $this->generator->expects($this->once())->method('createSessionConfig')->willReturn($configDataMock);
+        $this->generator->expects($this->once())->method('createDefinitionsConfig')->willReturn(null);
+        $this->generator->expects($this->once())->method('createDbConfig')->willReturn($configDataMock);
+        $this->generator->expects($this->once())->method('createResourceConfig')->willReturn($configDataMock);
+        $this->generator->expects($this->once())->method('createXFrameConfig')->willReturn($configDataMock);
+        $this->generator->expects($this->once())->method('createCacheHostsConfig')->willReturn($configDataMock);
+        $configData = $this->object->createConfig([], $this->deploymentConfig);
+        $this->assertEquals(8, count($configData));
+    }
+
+    public function testValidateSuccess()
+    {
+        $options = [
+            ConfigOptionsListConstants::INPUT_KEY_DB_PREFIX => 'prefix',
+            ConfigOptionsListConstants::INPUT_KEY_SESSION_SAVE => 'files',
+            ConfigOptionsListConstants::INPUT_KEY_SKIP_DB_VALIDATION => false,
+            ConfigOptionsListConstants::INPUT_KEY_DB_NAME => 'name',
+            ConfigOptionsListConstants::INPUT_KEY_DB_HOST => 'host',
+            ConfigOptionsListConstants::INPUT_KEY_DB_USER => 'user',
+            ConfigOptionsListConstants::INPUT_KEY_DB_PASSWORD => 'pass'
+        ];
+        $this->prepareValidationMocks();
+        $this->assertEquals([], $this->object->validate($options, $this->deploymentConfig));
+    }
+
+    public function testValidateInvalidSessionHandler()
+    {
+        $invalidSaveHandler = 'clay-tablet';
+
+        $options = [
+            ConfigOptionsListConstants::INPUT_KEY_DB_PREFIX => 'prefix',
+            ConfigOptionsListConstants::INPUT_KEY_SESSION_SAVE => $invalidSaveHandler,
+            ConfigOptionsListConstants::INPUT_KEY_SKIP_DB_VALIDATION => false,
+            ConfigOptionsListConstants::INPUT_KEY_DB_NAME => 'name',
+            ConfigOptionsListConstants::INPUT_KEY_DB_HOST => 'host',
+            ConfigOptionsListConstants::INPUT_KEY_DB_USER => 'user',
+            ConfigOptionsListConstants::INPUT_KEY_DB_PASSWORD => 'pass'
+        ];
+        $this->prepareValidationMocks();
+        $this->assertEquals(
+            ["Invalid session handler '$invalidSaveHandler'"],
+            $this->object->validate($options, $this->deploymentConfig)
+        );
+    }
+
+    private function prepareValidationMocks()
+    {
+        $configDataMock = $this->getMockBuilder('Magento\Framework\Config\Data\ConfigData')
+            ->disableOriginalConstructor()
+            ->getMock();
+        $this->dbValidator->expects($this->once())->method('checkDatabaseTablePrefix')->willReturn($configDataMock);
+        $this->dbValidator->expects($this->once())->method('checkDatabaseConnection')->willReturn($configDataMock);
+    }
+
+    /**
+     * @param string $hosts
+     * @param bool $expectedError
+     * @dataProvider validateCacheHostsDataProvider
+     */
+    public function testValidateCacheHosts($hosts, $expectedError)
+    {
+        $options = [
+            ConfigOptionsListConstants::INPUT_KEY_SKIP_DB_VALIDATION => true,
+            ConfigOptionsListConstants::INPUT_KEY_CACHE_HOSTS => $hosts
+        ];
+        $result = $this->object->validate($options, $this->deploymentConfig);
+        if ($expectedError) {
+            $this->assertCount(1, $result);
+            $this->assertEquals("Invalid http cache hosts '$hosts'", $result[0]);
+        } else {
+            $this->assertCount(0, $result);
+        }
+
+    }
+
+    public function validateCacheHostsDataProvider()
+    {
+        return [
+            ['localhost', false],
+            ['122.11.2.34:800', false],
+            ['122.11.2.34:800,localhost', false],
+            ['website.com:9000', false],
+            ['website.com/m2ce:9000', true],
+            ['website.com+:9000', true],
+        ];
+    }
+}
diff --git a/setup/src/Magento/Setup/Test/Unit/Module/ConfigOptionsListTest.php b/setup/src/Magento/Setup/Test/Unit/Module/ConfigOptionsListTest.php
deleted file mode 100644
index 1cf524b..0000000
--- a/setup/src/Magento/Setup/Test/Unit/Module/ConfigOptionsListTest.php
+++ /dev/null
@@ -1,185 +0,0 @@
-<?php
-/**
- * Copyright Â© 2016 Magento. All rights reserved.
- * See COPYING.txt for license details.
- */
-
-namespace Magento\Setup\Test\Unit\Module;
-
-use Magento\Setup\Model\ConfigGenerator;
-use Magento\Setup\Model\ConfigOptionsList;
-use Magento\Setup\Validator\DbValidator;
-use Magento\Framework\Config\ConfigOptionsListConstants;
-
-class ConfigOptionsListTest extends \PHPUnit_Framework_TestCase
-{
-    /**
-     * @var ConfigOptionsList
-     */
-    private $object;
-
-    /**
-     * @var ConfigGenerator|\PHPUnit_Framework_MockObject_MockObject
-     */
-    private $generator;
-
-    /**
-     * @var \PHPUnit_Framework_MockObject_MockObject|\Magento\Framework\App\DeploymentConfig
-     */
-    private $deploymentConfig;
-
-    /**
-     * @var DbValidator|\PHPUnit_Framework_MockObject_MockObject
-     */
-    private $dbValidator;
-
-    protected function setUp()
-    {
-        $this->generator = $this->getMock('Magento\Setup\Model\ConfigGenerator', [], [], '', false);
-        $this->deploymentConfig = $this->getMock('Magento\Framework\App\DeploymentConfig', [], [], '', false);
-        $this->dbValidator = $this->getMock('Magento\Setup\Validator\DbValidator', [], [], '', false);
-        $this->object = new ConfigOptionsList($this->generator, $this->dbValidator);
-    }
-
-    public function testGetOptions()
-    {
-        $options = $this->object->getOptions();
-        $this->assertInstanceOf('Magento\Framework\Setup\Option\TextConfigOption', $options[0]);
-        $this->assertSame('Encryption key', $options[0]->getDescription());
-        $this->assertInstanceOf('Magento\Framework\Setup\Option\SelectConfigOption', $options[1]);
-        $this->assertSame('Session save handler', $options[1]->getDescription());
-        $this->assertInstanceOf('Magento\Framework\Setup\Option\SelectConfigOption', $options[2]);
-        $this->assertSame('Type of definitions used by Object Manager', $options[2]->getDescription());
-        $this->assertInstanceOf('Magento\Framework\Setup\Option\TextConfigOption', $options[3]);
-        $this->assertSame('Database server host', $options[3]->getDescription());
-        $this->assertInstanceOf('Magento\Framework\Setup\Option\TextConfigOption', $options[4]);
-        $this->assertSame('Database name', $options[4]->getDescription());
-        $this->assertInstanceOf('Magento\Framework\Setup\Option\TextConfigOption', $options[5]);
-        $this->assertSame('Database server username', $options[5]->getDescription());
-        $this->assertInstanceOf('Magento\Framework\Setup\Option\TextConfigOption', $options[6]);
-        $this->assertSame('Database server engine', $options[6]->getDescription());
-        $this->assertInstanceOf('Magento\Framework\Setup\Option\TextConfigOption', $options[7]);
-        $this->assertSame('Database server password', $options[7]->getDescription());
-        $this->assertInstanceOf('Magento\Framework\Setup\Option\TextConfigOption', $options[8]);
-        $this->assertSame('Database table prefix', $options[8]->getDescription());
-        $this->assertInstanceOf('Magento\Framework\Setup\Option\TextConfigOption', $options[9]);
-        $this->assertSame('Database type', $options[9]->getDescription());
-        $this->assertInstanceOf('Magento\Framework\Setup\Option\TextConfigOption', $options[10]);
-        $this->assertSame('Database  initial set of commands', $options[10]->getDescription());
-        $this->assertInstanceOf('Magento\Framework\Setup\Option\FlagConfigOption', $options[11]);
-        $this->assertSame(
-            'If specified, then db connection validation will be skipped',
-            $options[11]->getDescription()
-        );
-        $this->assertInstanceOf('Magento\Framework\Setup\Option\TextConfigOption', $options[12]);
-        $this->assertSame('http Cache hosts', $options[12]->getDescription());
-        $this->assertEquals(13, count($options));
-    }
-
-    public function testCreateOptions()
-    {
-        $configDataMock = $this->getMock('Magento\Framework\Config\Data\ConfigData', [], [], '', false);
-        $this->generator->expects($this->once())->method('createInstallConfig')->willReturn($configDataMock);
-        $this->generator->expects($this->once())->method('createCryptConfig')->willReturn($configDataMock);
-        $this->generator->expects($this->once())->method('createSessionConfig')->willReturn($configDataMock);
-        $this->generator->expects($this->once())->method('createDefinitionsConfig')->willReturn($configDataMock);
-        $this->generator->expects($this->once())->method('createDbConfig')->willReturn($configDataMock);
-        $this->generator->expects($this->once())->method('createResourceConfig')->willReturn($configDataMock);
-        $this->generator->expects($this->once())->method('createXFrameConfig')->willReturn($configDataMock);
-        $this->generator->expects($this->once())->method('createCacheHostsConfig')->willReturn($configDataMock);
-        $configData = $this->object->createConfig([], $this->deploymentConfig);
-        $this->assertEquals(9, count($configData));
-    }
-
-    public function testCreateOptionsWithOptionalNull()
-    {
-        $configDataMock = $this->getMock('Magento\Framework\Config\Data\ConfigData', [], [], '', false);
-        $this->generator->expects($this->once())->method('createInstallConfig')->willReturn($configDataMock);
-        $this->generator->expects($this->once())->method('createCryptConfig')->willReturn($configDataMock);
-        $this->generator->expects($this->once())->method('createSessionConfig')->willReturn($configDataMock);
-        $this->generator->expects($this->once())->method('createDefinitionsConfig')->willReturn(null);
-        $this->generator->expects($this->once())->method('createDbConfig')->willReturn($configDataMock);
-        $this->generator->expects($this->once())->method('createResourceConfig')->willReturn($configDataMock);
-        $this->generator->expects($this->once())->method('createXFrameConfig')->willReturn($configDataMock);
-        $this->generator->expects($this->once())->method('createCacheHostsConfig')->willReturn($configDataMock);
-        $configData = $this->object->createConfig([], $this->deploymentConfig);
-        $this->assertEquals(8, count($configData));
-    }
-
-    public function testValidateSuccess()
-    {
-        $options = [
-            ConfigOptionsListConstants::INPUT_KEY_DB_PREFIX => 'prefix',
-            ConfigOptionsListConstants::INPUT_KEY_SESSION_SAVE => 'files',
-            ConfigOptionsListConstants::INPUT_KEY_SKIP_DB_VALIDATION => false,
-            ConfigOptionsListConstants::INPUT_KEY_DB_NAME => 'name',
-            ConfigOptionsListConstants::INPUT_KEY_DB_HOST => 'host',
-            ConfigOptionsListConstants::INPUT_KEY_DB_USER => 'user',
-            ConfigOptionsListConstants::INPUT_KEY_DB_PASSWORD => 'pass'
-        ];
-        $this->prepareValidationMocks();
-        $this->assertEquals([], $this->object->validate($options, $this->deploymentConfig));
-    }
-
-    public function testValidateInvalidSessionHandler()
-    {
-        $invalidSaveHandler = 'clay-tablet';
-
-        $options = [
-            ConfigOptionsListConstants::INPUT_KEY_DB_PREFIX => 'prefix',
-            ConfigOptionsListConstants::INPUT_KEY_SESSION_SAVE => $invalidSaveHandler,
-            ConfigOptionsListConstants::INPUT_KEY_SKIP_DB_VALIDATION => false,
-            ConfigOptionsListConstants::INPUT_KEY_DB_NAME => 'name',
-            ConfigOptionsListConstants::INPUT_KEY_DB_HOST => 'host',
-            ConfigOptionsListConstants::INPUT_KEY_DB_USER => 'user',
-            ConfigOptionsListConstants::INPUT_KEY_DB_PASSWORD => 'pass'
-        ];
-        $this->prepareValidationMocks();
-        $this->assertEquals(
-            ["Invalid session handler '$invalidSaveHandler'"],
-            $this->object->validate($options, $this->deploymentConfig)
-        );
-    }
-
-    private function prepareValidationMocks()
-    {
-        $configDataMock = $this->getMockBuilder('Magento\Framework\Config\Data\ConfigData')
-            ->disableOriginalConstructor()
-            ->getMock();
-        $this->dbValidator->expects($this->once())->method('checkDatabaseTablePrefix')->willReturn($configDataMock);
-        $this->dbValidator->expects($this->once())->method('checkDatabaseConnection')->willReturn($configDataMock);
-    }
-    
-    /**
-     * @param string $hosts
-     * @param bool $expectedError
-     * @dataProvider validateCacheHostsDataProvider
-     */
-    public function testValidateCacheHosts($hosts, $expectedError)
-    {
-        $options = [
-            ConfigOptionsListConstants::INPUT_KEY_SKIP_DB_VALIDATION => true,
-            ConfigOptionsListConstants::INPUT_KEY_CACHE_HOSTS => $hosts
-        ];
-        $result = $this->object->validate($options, $this->deploymentConfig);
-        if ($expectedError) {
-            $this->assertCount(1, $result);
-            $this->assertEquals("Invalid http cache hosts '$hosts'", $result[0]);
-        } else {
-            $this->assertCount(0, $result);
-        }
-
-    }
-
-    public function validateCacheHostsDataProvider()
-    {
-        return [
-            ['localhost', false],
-            ['122.11.2.34:800', false],
-            ['122.11.2.34:800,localhost', false],
-            ['website.com:9000', false],
-            ['website.com/m2ce:9000', true],
-            ['website.com+:9000', true],
-        ];
-    }
-}
